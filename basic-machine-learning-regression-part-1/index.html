<!doctype html><html><head><meta charset=utf-8><meta name=description content="Blogs on Machine Learning, Advanced Python and Algorithms"><meta name=keywords content="machine learning,deep learning,python,algorithms,java,code,programming,hooli,regression,convolutional neural networks,recurrent neural networks,neural networks,CNN,RNN,logistic regression,natural language processing,NLP"><meta name=author content="Abhishek Patel"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>Basic Machine Learning - Regression (Part 1)</title><link href=/css/app.css rel=stylesheet><link href='//fonts.googleapis.com/css?family=Roboto:400,300' rel=stylesheet type=text/css><link href="https://fonts.googleapis.com/css?family=Open+Sans|Open+Sans+Condensed:300" rel=stylesheet><script src=/js/jquery-3.2.1.min.js type=text/javascript></script>
<script src=/js/showdown.min.js type=text/javascript></script>
<script src=/js/main.js type=text/javascript></script>
<link rel=stylesheet type=text/css href=/css/viewing.css><link rel="shortcut icon" href=/img/favicon.ico><link rel=stylesheet type=text/css href=/css/code.css><script type=text/javascript src=https://blog.apbytes.com/js/highlight.pack.js></script>
<script>hljs.initHighlightingOnLoad()</script><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><nav class="navbar navbar-default-blanca navbar-fixed-top"><div class=container-fluid><div class=navbar-header><button type=button class="navbar-toggle collapsed" data-toggle=collapse data-target=#bs-example-navbar-collapse-1>
<span class=sr-only>Toggle Navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button>
<a class="navbar-brand name-plate" href=https://abhishek8394.github.io/blogs/>Home</a></div><div class="collapse navbar-collapse" id=bs-example-navbar-collapse-1><ul class="nav navbar-nav"><li><a href=http://www.apbytes.com>About Me</a></li></ul></div></div></nav><div class="blog-head blogBanner"><h1 class=blog-title>Basic Machine Learning - Regression (Part 1)</h1><h5 class=blog-date>Posted <span class=catchDate>September 19, 2017</span></h5></div><div class=container><div class=blog-reader-container><div class=blog-content><h2 id=hello-world>Hello World!</h2><p>This is the first blog in a series of blogs on machine learning techniques. Machine Learning is the new cool buzzword and for good reason. The impact is immense and to the untrained eye; it is magic. But with this series of blogs, hopefully you&rsquo;ll cross over to the other side and be the one doing all the magic stuff!</p><h2 id=first-cool-word---regression>First cool word - Regression</h2><p>Alright, so we begin our journey in this rabbit hole called <em>Machine Learning (ML)</em> with something simple yet powerful, a technique called <strong>Regression</strong>. This is really the <code>"Hello World"</code> equivalent of machine learning. Regression is not as complicated as it sounds (sounds cool though). Basically regression is about predictions. It is a technique to study some data, learn/estimate the underlying pattern and make predictions based on that.</p><p>We can perform classification where we &ldquo;predict&rdquo; the category or (class or labels in ML speak) for some given input. So for example if we wish to develop a spam filter, we might have categories to classify an e-mail into &ldquo;spam&rdquo; or &ldquo;not spam&rdquo;. Another type of prediction is about predicting an actual value. Say you&rsquo;re trying to sell/buy a house, then based on the past prices you can predict the prices at several points in future and this can help you take a more informed decision. All of this can be done with the so called <code>"Hello World"</code> of Machine Learning!</p><p>Before diving deeper, here are some more cool words used with regression that the community likes and you&rsquo;ll often see in ML literature. When we try to predict something, we are studying some data first. This data basically tells us about things that may or may not be relevant in making our predictions. So in case of our house prices, the data can be about the size of the house, number of rooms, etc. These are the <strong>&ldquo;features&rdquo;</strong> of the house. These features help us make our <strong>&ldquo;prediction&rdquo;</strong> and our often referred to as <strong>features</strong> or <strong>predictor variables</strong>. Now our prediction <em>depends</em> on the features in our dataset and so it is called the <strong>dependent variable</strong>. So in a way, our <strong>predictor variables</strong> our <strong>independent variables</strong>. So our inputs are called <em>feature / predictor / independent variables</em> while our output is called the <em>dependent variable</em>.
In this post, we will be discussing <em>Logistic Regression</em>, a popular algorithm used mostly for classification tasks.</p><h2 id=even-cooler-word---logistic-regression>Even cooler word - Logistic Regression</h2><p>Logistic regression is all about predicting a <em>class</em> for your input data. Given an input, you determine which class it belongs to. The simplest examples deal with just two classes, a binary classification task. This include tasks like spam or not spam, happy tweet vs a depressing tweet and so on. Of course you can have a classifier choose from more than two classes, in which case it is called <em>Multinomial Logistic Regression</em> (another cool word to add in your ML dictionary).</p><p>Alright, so lets say you wish to build your own spam classifier. Now the first task is to select the <strong>features</strong>. These features are something that are used to determine if an email is a spam or not. For the sake of simplicity, let us assume that the features are <em>feature 1</em> and <em>feature 2</em> denoted by $x_1$ and $x_2$. Let&rsquo;s say we decide upon the following linear function</p><p>$$y = a x_1 + b x_2$$</p><p>Since we are trying to predict if the email is a spam or not, we are interested in the probability of it being a spam. So we pass the value of our linear function through something called a <em>sigmoid</em> function. This is because sigmoid function always returns a value between 0 and 1. This range is similar to what we need for a probability. The sigmoid function is given by the following equation.</p><p>$$σ(x) = 1 ⁄ (1 + e^{-x})$$</p><p>And this is what sigmoid looks like when plotted on a graph:</p><figure class=figure><img src=https://upload.wikimedia.org/wikipedia/commons/thumb/8/88/Logistic-curve.svg/480px-Logistic-curve.svg.png alt="Sigmoid Graph"><figcaption><p>Image Courtesy: <a href="https://commons.wikimedia.org/w/index.php?curid=4310325">Qef at Wikimedia</a></p></figcaption></figure><p>As you can see, the output ranges from 0 to 1 on the negative and positive ends respectively, and is 0.5 when the input is zero. Hence we can provide it with any number and get a number between 0 and 1 back. So our spam filtering function will look like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>isSpam</span>(y):
</span></span><span style=display:flex><span>    probability <span style=color:#f92672>=</span> sigmoid(y)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> probability <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0.5</span>
</span></span></code></pre></div><p>Now the goal here is to learn the <em>parameters</em> <strong>a</strong> and <strong>b</strong> such that after applying the sigmoid function we get a number greather than 0.5 for spam mails. We already have the data from which we can learn, the question is how to learn the parameters from that data. Well, we guess the values initially and see how it works for the training data. And then we <em>adjust</em> these values by comparing our predictions with actual answers. In order to accomplish this, we need our next cool word, <strong>loss function</strong>.</p><h2 id=loss-function>Loss Function</h2><p>So what a loss function does is, well; tells you your loss. This function will tell us how far we are from the correct answer. It is our feedback system which will provide us with hints about how we should adjust our learning parameters. Think of it as a little guide whose job is to point in the right direction. So for a problem like this, a popular loss function is already available, The <em>Cross Entropy</em> loss function. Before sticking the equation in your face I would digress here for a moment to explain what it really is and why it is useful.</p><h3 id=entropy>Entropy</h3><p>Let&rsquo;s say that you want to send a large message to your friend but you get charged for every bit you send (you kinda do). Now one way to minimize the cost would be to send the message with as little bits as possible. We do that by picking short binary representations for most frequent alphabets and larger ones for the relatively rare ones. This way we can bring the cost down. The minimum number of bits you will need is given by $log(1/p_x)$ where <em>p</em> is the probability of seeing symbol <em>x</em>. So if letter $x_1$ occurs about 64 times more than letter $x_2$, then</p><p>$$
\begin{eqnarray}
bits\_x1 &=& log (1 / 64 * p(x_2)) \nonumber \\\
&=& log(1/64) + log(1/p(x_2)) \\\
&=& -6 + bits\_x2 \\\
\end{eqnarray}
$$</p><p>So you would use about 6 bits less for letter $x_1$ than for $x_2$. For our entire message, the entropy will be the <strong>expected</strong> number of bits we used for our encoding. Expectation means the average value seen over a series of experiments. For a experiment of rolling dice, the expected value is <code>3.5</code> since we see all <code>6</code> values equal number of times (equal probability). Mathematically, you get expectation by summing up the products of value with their respective probabilities. You can check that that will give <code>3.5</code> for a fair dice. Below is a one liner to calculate entropy.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>entropy <span style=color:#f92672>=</span> sum([x<span style=color:#f92672>*</span>log(<span style=color:#ae81ff>1</span><span style=color:#f92672>/</span>x) <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> probability_of_symbols]
</span></span></code></pre></div><p>Here we used our knowledge of data distribution to encode symbols. Now suppose we didn&rsquo;t know the distribution, we would be encoding based on a guessed distribution <strong>H&rsquo;</strong> then. This will always be greater than or equal to the actual entropy <strong>H</strong> since that is the minimum. Now if our guessed distribution uses the probability function <strong>p&rsquo;(x)</strong> instead of the correct one <strong>p(x)</strong>, then <strong>cross entropy</strong> <em><strong>H(p, p&rsquo;)</strong></em> will be the number of bits we will need with this new distribution given as:</p><p>$$H(p,p&rsquo;) = ∑ p\ log(1/p&rsquo;) = − ∑ p\ log (p&rsquo;)$$</p><p>So going back to our cross entropy loss, we are detecting probabilities of an email being a spam. Lets say <strong>y</strong> is the actual probability of it being a spam and <strong>a</strong> is the one our algorithm detects. We have only two possible inputs, a spam email (prob: p) and a non-spam email (prob: 1-p). Hence our cross entropy summation will expand to just two terms;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>cross_entropy <span style=color:#f92672>=</span> <span style=color:#f92672>-</span> y <span style=color:#f92672>*</span> log(a) <span style=color:#f92672>-</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> y) <span style=color:#f92672>*</span> log(<span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> a)
</span></span></code></pre></div><p>Interesting things to note:</p><ul><li>The input to log is always between 0 and 1, hence output is negative, and with the negative signs outside, our cross entropy will always be positive.</li><li>If <strong>y</strong> is 0 and <strong>a</strong> is close to 0; or if <strong>y</strong> is 1 and <strong>a</strong> is close to 1, our cross entropy is 0 ($∵ log(1) = 0$ and while $log(0)$ is undefined, its partner becomes 0).</li><li>If <strong>y</strong> is 0 and <strong>a</strong> is close to 1; or if <strong>y</strong> is 1 and <strong>a</strong> is close to 0, our cross entropy starts growing high.</li></ul><p>All those features are what we desire from a loss function: it stays positive, returns 0 when we are right and higher values as we go more wrong. Hence over our training data with <em>n</em> examples, our loss over the entire dataset, the <em>cross entropy loss</em> will be average of the cross entropy over all training examples, where we calculate cross entropy for each based on the previous formula.
$$H(p,p&rsquo;) = -1/n ∑ (cross\_entropies)$$</p><p>Okay, like any sane person we are trying to minimize the loss function and that is how we measure the effectiveness of our learning parameters. In order to actually get our parameters <strong>a</strong> and <strong>b</strong> from this loss function, we have two ways:</p><ul><li>Solve the problem of $minarg(H(p,p&rsquo;))$ w.r.t. to $a$ and $b$. Sparing the equations, intuitively our loss function can be thought of as a curved surface in 3D where two of the dimensions are our inputs and the third one is our loss function. We are then trying to find the lowest point (minimum loss) on the surface. At the lowest point, the derivative of the curve will be zero and hence you can solve for that. But that quickly gets out of hand for more number of parameters and hard to differentiate functions.</li><li>A technique called <a href=https://en.wikipedia.org/wiki/Gradient_descent>Gradient Descent</a>. This technique merits a blog of its own (maybe in future) but here&rsquo;s a quick overview. At a point on the curve, you look around to see which direction has the steepest slope downwards (since we are trying to minimize loss) and then you take a small step in that direction. And then you repeat the process again till you have reached the minimal point.</li></ul><p>Of course these techniques face the risk of being stuck in a local minima, a point where it seems that this is the lowest point when you look around but is not the globally lowest point. It is like falling in a pit and thinking if you&rsquo;ve reached the center of the earth. Anyways, those issues are a thing of their own, but for now don&rsquo;t worry about those and trust that these techniques work (they do!).</p></div></div></div></body></html>